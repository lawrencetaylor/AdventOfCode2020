module Day09 where

import           Advent.Parsing (pDayLines, pInt)
import           Data.List      (tails)

{-|
For a sequence [ a, b, c, d, e, ...]
constructs a sequence
[a+b, a+c, a+d, a+e, etc, ...]
-}
pairSums ::[Int] -> [Int]
pairSums (x:xs) = fmap (x +) xs

{-|
For a sequence [ a, b, c, d, e, ...]
constructs a sequence
[a+b, a+b+c, a+b+c+d, etc. ]
-}
partialSums ::[Int] -> [Int]
partialSums (x:y:xs) = (x+y) : ((x +) <$>  partialSums (y:xs))

{-|
Creates a list of lists!
Each "inner" list is generated by applying f to each tail
-}
listOfSums :: ([Int] ->[Int]) -> [Int] -> PartialSums
listOfSums f x = f <$> tails  x

type PartialSums = [[Int]]

{-|
Let's find the single entry that is not the sum
of two numbers in the previous "w" entries.

We solve this by creating a sequence of "pair sums":

| 1 | 2 | 3 | 4  |
|---|---|---|----|
| 3 | 5 | 7 | 9  |
| 4 | 6 | 8 | 10 |
| 5 | 7 | 9 | 11 |

For a pre-amble size of 2:
* To check if 3 is valid we need to check the triangle of [[3,4],[5]]
* To check if 4 is valid we need to check the triangle of [[5,6],[7]]
-}
partOne :: Int ->  [Int] -> Int
partOne w input = snd
  $ head
  $ filter (not . fst)
  $ getValidity input sums w <$> [w+1..]
  where
      sums = listOfSums pairSums input

      getValidity ::
        [Int] -- ^ The entire list of numbers
        -> PartialSums
        -> Int  -- ^ The "preamble size"
        -> Int  -- ^ The index currently being tested
        -> (Bool, Int)  {- ^ A tuple indicating whether:
                            * Whether the value at the specified index is valid;
                            * The value at that index.
                        -}
      getValidity numbers sums w i = (isValid, toFind)
        where
          toFind =  numbers !! i
          end = i - 2
          start = end - w + 1
          validSums = [  (sums !! i) !! j | i <- [start..end], j <- [0..w - 1] , i - start + j < w ]
          isValid = toFind `elem` validSums

{-|
Now we are trying to find the contiguous entries in the input that
sum to a given target.

Again we generate a table of sums - this time of all possible sums

| 1  | 2  | 3  | 4  |
|----|----|----|----|
| 3  | 5  | 7  | 9  |
| 6  | 9  | 12 | .. |
| 10 | 14 | .. | .. |

If we find our target in this table, we can read off (i,j) and look at the
slice [i..j] in our original input.
-}
partTwo :: Int -> [Int] -> Int
partTwo target input = minimum entries + maximum entries
  where
    sums = listOfSums partialSums input

    {-|
    Generates a squence of tuples consisting of:
    * The sum of contiguous entries in the input, whose value is less than or equal to the "target sum"
    * The array of those contiguous entries
    -}
    partialSumsWithTerms i = [ ((sums !! i) !! j, take (j + 2) $ drop i input) |  j <- [0..] ]

    (_, entries) =
      head $
      filter (\t -> fst t == target) $
      concat $
      takeWhile (\t -> fst t <= target) . partialSumsWithTerms <$> [0..]

main :: IO ()
main = do
  input <- pDayLines 9 pInt
  let invalidEntry = partOne 25 input
  putStrLn $ "Part One: " ++ show invalidEntry
  putStrLn $ "Part Two: " ++ show (partTwo invalidEntry input)
